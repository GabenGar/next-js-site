---
title: "PostgreSQL and NextJS (Part 2)"
created_at: "2022-02-17T14:06:03.295Z"
edited_at: null
author: "Gabengar"
---

## PostgreSQL integration for the NextJS poject.

# PostgreSQL and NextJS (Part 2)

## Abstract

Because NextJS is serverless, the package responsible for managing DB interaction, `pg-promise`, will have to work slightly differently.

## File structure

Since we are not using ORM, the main interactions with DB will happen through SQL statements, which is its own language. In order not to pollute the code base with SQL string literals, limit their declaration within a single module/folder. In case of this article they will be limited to `src/database`.

## Preparation

1. Install `pg-promise`:

   ```sh
   npm install pg-promise
   ```

2. Create a helper function which allows this package to work with NextJS, as per [the post by the package author (**UPDATE-2**)](https://stackoverflow.com/questions/34382796/where-should-i-initialize-pg-promise/34427278#34427278) let's say in `src/lib/util.ts`:

   ```ts
   export function createSingleton<T>(name: string, create: () => T): T {
     const s = Symbol.for(name);
     let scope = (global as any)[s];
     if (!scope) {
       scope = { ...create() };
       (global as any)[s] = scope;
     }
     return scope;
   }
   ```

3. Create a `lib.ts` file inside `src/database` and populate it like this:

   ```ts
   import path from "path";
   import pgLib from "pg-promise";

   import { createSingleton } from "../lib/util";

   import type { IInitOptions, IDatabase, IMain } from "pg-promise";

   interface IDatabaseScope {
     db: IDatabase<any>;
     pgp: IMain;
   }

   const initOptions: IInitOptions = {};
   const pgp = pgLib(initOptions);

   export function getDB(): IDatabaseScope {
     return createSingleton<IDatabaseScope>("db-scope", () => {
       return {
         db: pgp(process.env.DATABASE_URL),
         pgp,
       };
     });
   }
   ```

Use `getDB()` at the module scope which is going to have DB query functions.

## Interaction

In [the previous part](./nextjs-postgresql-migrations) we've created `accounts` table. Now we need to write a bunch of query functions to interact with it.

### Query functions

Majority of tables have these basic interactions:

- add one
- add many
- get all
- get one
- get many
- find one
- find many
- update one
- update many
- remove all
- remove one
- remove many

So in context of the accounts we need these functions at least:

- `addAccount()` - to add an account
- `getAccount()` - to fetch details of existing account
- `findAccount()` - find account according to search criteria
- `updateAccount()` - update an existing account

### Function signature

Notice how logic of all these functions only pertains to data manipuation without any business logic. You want to have DB accessing functions to be as pure as possible. Obviously they can't be completely pure, because their main purpose is to invoke a side effect. But not having extra logic bundled to them makes them more manageable (and in some cases reusable).

The signature for these functions looks like this:

```ts
async function queryDB<T>(...args): T;
```

Where `...args` is the minimal amount of arguments required to execute a query.

So assuming with the `Account` interface looking like this:

```ts
export interface Account {
  id?: number;
  created_at?: string;
  name: string;
  password?: string;
  email?: string;
}
```

The basic query functions will look like this:

```ts
async function addAccount(name: string, password: string): Account;
async function getAccount(account_id: number): Account;
async function findAccount(name: string, password: string): Account | undefined;
async function updateAccount(name: string): Account;
```

The difference between `get()` and `find()` gets more apparent there. `get()` is ran under assumption that row exists in the table (because it searches by the unique key generated by DB) and thus not returning any is considered an error. While `find()` is not guarantied to return a row and thus it's up to the calling function to handle the lack of results.

## SQL Queries

- `addAccount()` - adds an account and returns a freshly added row

  ```sql
  INSERT INTO accounts (name, password)
  VALUES ($(name), $(password))
  RETURNING *
  ```

- `getAccount()` - get account by id

  ```sql
  SELECT *
  FROM accounts
  WHERE id = $(id)
  ```

- `findAccount()` - find account by name and password

  ```sql
  SELECT *
  FROM accounts
  WHERE
    name = $(name)
    AND password = $(password)
  ```

- `updateAccount()` - update account's name by id and return the updated row.

  ```sql
  UPDATE accounts
  SET name = $(name)
  WHERE id = $(account_id)
  RETURNING *
  ```

